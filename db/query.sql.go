// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package db

import (
	"context"
	"database/sql"
)

const createScore = `-- name: CreateScore :exec
INSERT IGNORE INTO scores (
    name,
    gameNumber,
    secondsToSolve,
    timestamp
)
VALUES (
 ?,
 ?,
 ?,
 ?
)
`

type CreateScoreParams struct {
	Name           string
	Gamenumber     int32
	Secondstosolve int32
	Timestamp      int32
}

func (q *Queries) CreateScore(ctx context.Context, arg CreateScoreParams) error {
	_, err := q.db.ExecContext(ctx, createScore,
		arg.Name,
		arg.Gamenumber,
		arg.Secondstosolve,
		arg.Timestamp,
	)
	return err
}

const getFastestPlayersByMonth = `-- name: GetFastestPlayersByMonth :many
WITH monthly_fastest AS (
    SELECT
        name,
        DATE_FORMAT(FROM_UNIXTIME(timestamp), '%Y-%m') AS month,
    MIN(secondsToSolve) AS min_seconds
FROM
    scores
GROUP BY DATE_FORMAT(FROM_UNIXTIME(timestamp), '%Y-%m')
    )
SELECT
    name,
    GROUP_CONCAT(month ORDER BY month) AS months,
    COUNT(*) AS fastest_count
FROM
    monthly_fastest
GROUP BY name
ORDER BY fastest_count, name
`

type GetFastestPlayersByMonthRow struct {
	Name         string
	Months       sql.NullString
	FastestCount int64
}

func (q *Queries) GetFastestPlayersByMonth(ctx context.Context) ([]GetFastestPlayersByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getFastestPlayersByMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFastestPlayersByMonthRow
	for rows.Next() {
		var i GetFastestPlayersByMonthRow
		if err := rows.Scan(&i.Name, &i.Months, &i.FastestCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastestPlayersByWeek = `-- name: GetFastestPlayersByWeek :many
WITH weekly_fastest AS (
    SELECT
        name,
        DATE_FORMAT(FROM_UNIXTIME(timestamp), '%Y-%u') AS week,
    MIN(secondsToSolve) AS min_seconds
FROM
    scores
GROUP BY DATE_FORMAT(FROM_UNIXTIME(timestamp), '%Y-%u')
    )
SELECT
    name,
    GROUP_CONCAT(week ORDER BY week) AS week,
    COUNT(*) AS fastest_count
FROM
    weekly_fastest
GROUP BY name
ORDER BY fastest_count, name
`

type GetFastestPlayersByWeekRow struct {
	Name         string
	Week         sql.NullString
	FastestCount int64
}

func (q *Queries) GetFastestPlayersByWeek(ctx context.Context) ([]GetFastestPlayersByWeekRow, error) {
	rows, err := q.db.QueryContext(ctx, getFastestPlayersByWeek)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFastestPlayersByWeekRow
	for rows.Next() {
		var i GetFastestPlayersByWeekRow
		if err := rows.Scan(&i.Name, &i.Week, &i.FastestCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastestTimeByMonth = `-- name: GetFastestTimeByMonth :many
SELECT
    name,
    gameNumber,
    MIN(secondsToSolve) AS minSecondsToSolve,
    DATE_FORMAT(FROM_UNIXTIME(timestamp), '%Y-%m') AS date
FROM
    scores
GROUP BY name, date
ORDER BY date, minSecondsToSolve
`

type GetFastestTimeByMonthRow struct {
	Name              string
	Gamenumber        int32
	Minsecondstosolve interface{}
	Date              string
}

func (q *Queries) GetFastestTimeByMonth(ctx context.Context) ([]GetFastestTimeByMonthRow, error) {
	rows, err := q.db.QueryContext(ctx, getFastestTimeByMonth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFastestTimeByMonthRow
	for rows.Next() {
		var i GetFastestTimeByMonthRow
		if err := rows.Scan(
			&i.Name,
			&i.Gamenumber,
			&i.Minsecondstosolve,
			&i.Date,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNames = `-- name: GetNames :many
SELECT DISTINCT
    name
FROM
    scores
`

func (q *Queries) GetNames(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getNames)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScores = `-- name: GetScores :many
SELECT
    id, name, gamenumber, secondstosolve, timestamp
FROM
    scores
`

func (q *Queries) GetScores(ctx context.Context) ([]Score, error) {
	rows, err := q.db.QueryContext(ctx, getScores)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Score
	for rows.Next() {
		var i Score
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gamenumber,
			&i.Secondstosolve,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getScoresByNames = `-- name: GetScoresByNames :many
SELECT
    id, name, gamenumber, secondstosolve, timestamp
FROM
    scores
WHERE
    name = ?
`

func (q *Queries) GetScoresByNames(ctx context.Context, name string) ([]Score, error) {
	rows, err := q.db.QueryContext(ctx, getScoresByNames, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Score
	for rows.Next() {
		var i Score
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Gamenumber,
			&i.Secondstosolve,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
